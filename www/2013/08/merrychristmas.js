// Generated by CoffeeScript 1.6.2
var Arcball, BoundingBox, Color, Cube, Diffuse, Face3, Geometry, IO, Mat4, MathUtils, Mesh, Octahedron, PI, PerspectiveCamera, Platform, Quat, RenderTarget, Scene, ScreenImage, ShowDepth, ShowNormals, SolidColor, Sphere, Texture2D, Time, Vec3, Viewport, Window, cos, floor, hem, partition, pex, random, sin, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

pex = pex || require('./lib/pex');

_ref = pex.sys, Window = _ref.Window, Platform = _ref.Platform, IO = _ref.IO;

_ref1 = pex.scene, PerspectiveCamera = _ref1.PerspectiveCamera, Arcball = _ref1.Arcball, Scene = _ref1.Scene;

_ref2 = pex.materials, SolidColor = _ref2.SolidColor, Diffuse = _ref2.Diffuse, ShowDepth = _ref2.ShowDepth, ShowNormals = _ref2.ShowNormals;

_ref3 = pex.gl, Mesh = _ref3.Mesh, Texture2D = _ref3.Texture2D, RenderTarget = _ref3.RenderTarget, Viewport = _ref3.Viewport, ScreenImage = _ref3.ScreenImage;

_ref4 = pex.geom, hem = _ref4.hem, Vec3 = _ref4.Vec3, BoundingBox = _ref4.BoundingBox, Geometry = _ref4.Geometry, Face3 = _ref4.Face3, Mat4 = _ref4.Mat4, Quat = _ref4.Quat;

_ref5 = pex.geom.gen, Cube = _ref5.Cube, Octahedron = _ref5.Octahedron, Sphere = _ref5.Sphere;

Color = pex.color.Color;

_ref6 = pex.utils, Time = _ref6.Time, MathUtils = _ref6.MathUtils;

cos = Math.cos, sin = Math.sin, PI = Math.PI, random = Math.random, floor = Math.floor;

/*
if !String.prototype.trim
  String.prototype.trim = () -> return this.replace(/^\s+|\s+$/g, '')
if !Array.prototype.partition
*/


partition = function(list, n) {
  var group, i, j, result, _i, _j, _ref7;

  result = [];
  for (i = _i = 0, _ref7 = list.length - 1; n > 0 ? _i <= _ref7 : _i >= _ref7; i = _i += n) {
    group = [];
    for (j = _j = 0; _j <= 1; j = ++_j) {
      group.push(list[i + j]);
    }
    result.push(group);
  }
  return result;
};

pex.require(['materials/FlatToonShading', 'utils/CameraOrbiter'], function(FlatToonShading, CameraOrbiter) {
  return Window.create({
    settings: {
      fullscreen: Platform.isBrowser
    },
    init: function() {
      this.dist = 6;
      this.angleStep = 37;
      this.camera = new PerspectiveCamera(45, this.width / this.height, this.dist - 5, this.dist);
      this.orbiter = new CameraOrbiter(this.camera, this.dist);
      this.progress = 0;
      this.tagetProgress = 0;
      this.frameCount = 0;
      this.colors = [Texture2D.load('assets/c1.png'), Texture2D.load('assets/c2.png'), Texture2D.load('assets/c3.png'), Texture2D.load('assets/c4.png'), Texture2D.load('assets/c5.png'), Texture2D.load('assets/c6.png'), Texture2D.load('assets/c7.png')];
      this.meshMaterial = new FlatToonShading({
        colorBands: this.colors[0],
        fogColor: new Color(0.2, 0.2, 0.2, 1.0)
      });
      if (this.orbiter) {
        this.orbiter.phi = -this.angleStep;
      }
      if (this.orbiter) {
        this.orbiter.targetPhi = 0;
      }
      this.meshes = [];
      this.textsToLoad = 0;
      this.addText('assets/merry-en.svg', new Vec3(0, 0, this.dist - 2.5), new Quat().setAxisAngle(new Vec3(0, 1, 0), this.angleStep * 0));
      this.addText('assets/merry-pl.svg', new Vec3(0, 0, this.dist - 2.5), new Quat().setAxisAngle(new Vec3(0, 1, 0), this.angleStep * 1));
      this.addText('assets/merry-kr.svg', new Vec3(0, 0, this.dist - 2.5), new Quat().setAxisAngle(new Vec3(0, 1, 0), this.angleStep * 2));
      this.addText('assets/merry-dk.svg', new Vec3(0, 0, this.dist - 2.5), new Quat().setAxisAngle(new Vec3(0, 1, 0), this.angleStep * 3));
      this.bar = document.getElementById('bar');
      return this.loader = document.getElementById('loader');
    },
    addText: function(url, translate, rotate) {
      var _this = this;

      this.textsToLoad++;
      return IO.loadTextFile(url, function(svg) {
        var triangles;

        triangles = [];
        svg.split('\n').forEach(function(line, lineIndex) {
          var pathData, triangleCoordinates;

          line = line.trim();
          if (line.substr(0, 3) === 'd="') {
            pathData = line.substr(3, line.length - 4);
            triangleCoordinates = constructPolygonFromSVGPath(pathData, {});
            return triangles.push(triangleCoordinates[0]);
          }
        });
        _this.meshes.push(_this.praperePoints(triangles, translate, rotate));
        return _this.targetProgress = _this.meshes.length / _this.textsToLoad || 0;
      });
    },
    praperePoints: function(triangles, translate, rotate) {
      var aspectRatio, bbox, bboxSize, camPos, points;

      triangles = triangles.map(function(coords) {
        return partition(coords, 2).map(function(coord) {
          return new Vec3(coord[0], coord[1], 0);
        });
      });
      points = [];
      triangles.forEach(function(trianglePoints) {
        return points = points.concat(trianglePoints);
      });
      bbox = BoundingBox.fromPoints(points);
      bboxSize = bbox.getSize();
      aspectRatio = bboxSize.y / bboxSize.x;
      points.forEach(function(p) {
        p.x = (p.x - bbox.min.x) / bboxSize.x - 0.5;
        p.y = -(p.y - bbox.min.y) / bboxSize.y * aspectRatio + aspectRatio / 2;
        p.scale(2);
        p.add(translate);
        return p.transformQuat(rotate);
      });
      camPos = this.camera.getPosition().dup();
      camPos.transformQuat(rotate);
      points.forEach(function(p) {
        var b;

        b = camPos.dup().sub(p).normalize().scale(random() * 0.3 - 0.15);
        return p.add(b);
      });
      triangles.forEach(function(trianglePoints) {
        var k;

        k = random() * 1 - 0.5;
        return trianglePoints.forEach(function(p) {
          var b;

          b = camPos.dup().sub(p).normalize().scale(k);
          return p.add(b);
        });
      });
      return this.buildMesh(triangles);
    },
    buildMesh: function(triangles) {
      var faces, geom, normals, vertices;

      geom = new Geometry({
        vertices: true,
        face: true,
        normals: true
      });
      vertices = geom.vertices;
      faces = geom.faces;
      normals = geom.normals;
      triangles.forEach(function(trianglePoints) {
        var ab, ac, n, numPoints;

        numPoints = vertices.length;
        n = new Vec3(random() - 0.5, random() - 0.5, random() - 0.5).normalize();
        ab = trianglePoints[1].dup().sub(trianglePoints[0]).normalize();
        ac = trianglePoints[2].dup().sub(trianglePoints[0]).normalize();
        n = ab.cross(ac);
        trianglePoints.forEach(function(point) {
          vertices.push(point);
          return normals.push(n);
        });
        return faces.push(new Face3(numPoints, numPoints + 1, numPoints + 2));
      });
      return new Mesh(geom, this.meshMaterial);
    },
    swapColor: function() {
      this.colors.push(this.colors.shift());
      return this.meshMaterial.uniforms.colorBands = this.colors[0];
    },
    update: function() {
      var _this = this;

      if (this.orbiter) {
        this.orbiter.phi += (this.orbiter.targetPhi - this.orbiter.phi) * 0.1;
      }
      if (this.orbiter) {
        this.orbiter.update();
      }
      this.frameCount++;
      if (this.frameCount % (90 * this.meshes.length) === 0) {
        setTimeout((function() {
          return _this.swapColor();
        }), 100);
        return this.orbiter.targetPhi = (floor(this.orbiter.targetPhi / 360) + 1) * 360;
      } else if (this.frameCount % 90 === 0) {
        if (this.orbiter) {
          return this.orbiter.targetPhi += this.angleStep;
        }
      }
    },
    updateProgress: function() {
      this.progress += (this.targetProgress - this.progress) * 0.05;
      return this.bar.style.width = (this.progress * 100) + '%';
    },
    draw: function() {
      var mesh, meshIndex, _i, _len, _ref7, _results;

      this.gl.clearColor(0.2, 0.2, 0.2, 1.0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.updateProgress();
      if (this.meshes.length < this.textsToLoad || this.progress < 0.99) {
        return;
      }
      this.loader.style.display = 'none';
      this.update();
      this.meshMaterial.uniforms.lightPos = this.camera.getPosition();
      this.meshMaterial.uniforms.near = this.camera.getNear();
      this.meshMaterial.uniforms.far = this.camera.getFar();
      _ref7 = this.meshes;
      _results = [];
      for (meshIndex = _i = 0, _len = _ref7.length; _i < _len; meshIndex = ++_i) {
        mesh = _ref7[meshIndex];
        _results.push(mesh.draw(this.camera));
      }
      return _results;
    }
  });
});
